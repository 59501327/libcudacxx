//===----------------------------------------------------------------------===//
//
// Part of the CUDA Toolkit, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _CUDA___THREADING_SUPPORT
#define _CUDA___THREADING_SUPPORT

#ifndef __CUDACC_RTC__
    #include <thread>
    #include <errno.h>
#endif


#include "../chrono"
#include "../climits"

#include "__config"

#include "libcxx/include/__threading_support"

#ifdef _MSC_VER

_LIBCUDACXX_BEGIN_NAMESPACE_STD

void __libcpp_thread_yield()
{
#ifdef __CUDA_ARCH__
  ;
#else
  ::std::this_thread::yield();
#endif
}

void __libcpp_thread_sleep_for(chrono::nanoseconds __ns)
{
#ifdef __CUDA_ARCH__
   auto const __step = __ns.count();
   assert(__step < numeric_limits<unsigned>::max());
   asm volatile ("nanosleep.u32 %0;"::"r"((unsigned)__step):);
#else
   ::std::this_thread::sleep_for(::std::chrono::nanoseconds(__ns.count()));
#endif
}

template<class _Fn>
bool __libcpp_thread_poll_with_backoff(_Fn && __f, chrono::nanoseconds __max)
{
    chrono::high_resolution_clock::time_point const __start = chrono::high_resolution_clock::now();
    for(int __count = 0;;) {
      if(__f())
        return true;
      if(__count < _LIBCUDACXX_POLLING_COUNT) {
        if(__count > (_LIBCUDACXX_POLLING_COUNT >> 1))
          __libcpp_thread_yield_processor();
        __count += 1;
        continue;
      }
      chrono::high_resolution_clock::duration const __elapsed = chrono::high_resolution_clock::now() - __start;
      if(__max != chrono::nanoseconds::zero() &&
         __max < __elapsed)
         return false;
      chrono::nanoseconds const __step = __elapsed / 4;
      if(__step >= chrono::milliseconds(1))
        __libcpp_thread_sleep_for(chrono::milliseconds(1));
      else if(__step >= chrono::microseconds(10))
        __libcpp_thread_sleep_for(__step);
      else
        __libcpp_thread_yield();
    }
}

_LIBCUDACXX_END_NAMESPACE_STD

#endif

#endif //_CUDA___THREADING_SUPPORT
